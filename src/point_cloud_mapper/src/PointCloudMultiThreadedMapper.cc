#include <omp.h>
#include <parameter_utils/ParameterUtils.h>
#include <pcl/octree/octree_iterator.h>
#include <pcl/search/impl/search.hpp>
#include <point_cloud_mapper/PointCloudMultiThreadedMapper.h>
#include <std_msgs/String.h>
namespace pu = parameter_utils;

PointCloudMultiThreadedMapper::PointCloudMultiThreadedMapper()
  : initialized_(false),
    map_updated_(false),
    incremental_unsubscribed_(false),
    b_keep_history_(false),
    refresh_id_("a") {
  history_.reset(new PointCloud);
  map_data_.reset(new PointCloud);
  map_data_b_.reset(new PointCloud);
}

PointCloudMultiThreadedMapper::~PointCloudMultiThreadedMapper() {
  if (publish_thread_.joinable()) {
    publish_thread_.join();
  }
}

bool PointCloudMultiThreadedMapper::Initialize(const ros::NodeHandle& n) {
  name_ = ros::names::append(n.getNamespace(), "PointCloudMultiThreadedMapper");

  if (!LoadParameters(n)) {
    ROS_ERROR("%s: Failed to load parameters.", name_.c_str());
    return false;
  }

  if (!RegisterCallbacks(n)) {
    ROS_ERROR("%s: Failed to register callbacks.", name_.c_str());
    return false;
  }

  return true;
}

bool PointCloudMultiThreadedMapper::LoadParameters(const ros::NodeHandle& n) {
  // Load fixed frame.
  if (!pu::Get("frame_id/fixed", fixed_frame_id_))
    return false;
  map_data_->header.frame_id = fixed_frame_id_;
  map_data_->header.frame_id = fixed_frame_id_;

  // Load map parameters.
  if (!pu::Get("map/octree_resolution", octree_resolution_))
    return false;
  if (!pu::Get("map/b_publish_only_with_subscribers",
               b_publish_only_with_subscribers_))
    return false;
  if (!pu::Get("map/b_publish_map_info", b_publish_map_info_))
    return false;
  if (!pu::Get("map/volume_voxel_size", volume_voxel_size))
    return false;

  // Initialize the map octree.
  map_octree_.reset(new Octree(octree_resolution_));
  map_octree_->setInputCloud(map_data_);

  initialized_ = true;

  return true;
}

bool PointCloudMultiThreadedMapper::RegisterCallbacks(
    const ros::NodeHandle& n) {
  // Create a local nodehandle to manage callback subscriptions.
  ros::NodeHandle nl(n);

  map_pub_ = nl.advertise<PointCloud>("octree_map", 10, true);
  incremental_map_pub_ =
      nl.advertise<PointCloud>("octree_map_updates", 10, true);
  map_frozen_pub_ = nl.advertise<PointCloud>("octree_map_frozen", 10, false);
  map_info_pub_ = nl.advertise<core_msgs::MapInfo>("map_info", 10, false);

  search_in_map_pub_ =
      nl.advertise<std_msgs::Float64>("search_in_map", 10, false);
  delete_from_map_pub_ =
      nl.advertise<std_msgs::Float64>("delete_from_map", 10, false);
  adding_to_map_pub_ =
      nl.advertise<std_msgs::Float64>("adding_to_map", 10, false);

  no_insert_points_pub_ =
      nl.advertise<std_msgs::UInt64>("no_insert_points_pub", 10, false);

  no_nearest_points_pub_ =
      nl.advertise<std_msgs::UInt64>("no_nearest_points", 10, false);

  return true;
}

void PointCloudMultiThreadedMapper::Reset() {
  map_data_.reset(new PointCloud);
  map_data_->header.frame_id = fixed_frame_id_;
  map_octree_.reset(new Octree(octree_resolution_));
  map_octree_->setInputCloud(map_data_);

  initialized_ = true;
}

bool PointCloudMultiThreadedMapper::InsertPoints(
    const PointCloud::ConstPtr& points, PointCloud* incremental_points) {
  if (!initialized_) {
    ROS_ERROR("%s: Not initialized.", name_.c_str());
    return false;
  }

  if (incremental_points == NULL) {
    ROS_ERROR("%s: Incremental point cloud argument is null.", name_.c_str());
    return false;
  }
  incremental_points->clear();
  // TODO: add here:   incremental_points->resize(points->points.size());
  auto no_points = std_msgs::UInt64();
  no_points.data = points->size();
  no_insert_points_pub_.publish(no_points);
  // Try to get the map mutex from the publisher. If the publisher is using it,
  // we will just not insert this point cloud right now. It'll be added when the
  // map is regenerated by loop closure.

  auto t_start = std::chrono::high_resolution_clock::now();

  if (refresh_id_ == "a") {
    if (map_mutex_.try_lock()) {
      if (b_add_history_to_a_) {
        auto add_history_start_time = std::chrono::system_clock::now();
        auto history_size = history_->points.size();
        std::cout << history_size << std::endl;
        for (size_t ii = 0; ii < history_->points.size(); ++ii) {
          const Point p = points->points[ii];
          map_octree_->addPointToCloud(p, map_data_);
        }
        auto add_history_end_time = std::chrono::system_clock::now();
        std::chrono::duration<double> add_history_duration =
            add_history_end_time - add_history_start_time;
        ROS_INFO_STREAM("Added history in " << add_history_duration.count()
                                            << " s");
        history_->clear();
        b_add_history_to_a_ = false;
      }

      double min_x, min_y, min_z, max_x, max_y, max_z;
      bool isInBox;
      map_octree_->getBoundingBox(min_x, min_y, min_z, max_x, max_y, max_z);
      // Iterate over points in the input point cloud, inserting them into the
      // map if there is not already a point in the same voxel.
      for (size_t ii = 0; ii < points->points.size(); ++ii) {
        const Point p = points->points[ii];
        isInBox = (p.x >= min_x && p.x <= max_x) &&
            (p.y >= min_y && p.y <= max_y) && (p.z >= min_z && p.z <= max_z);
        if (!isInBox || !map_octree_->isVoxelOccupiedAtPoint(p)) {
          map_octree_->addPointToCloud(p, map_data_);
          incremental_points->push_back(p);
          if (b_keep_history_)
            history_->push_back(
                p); // This history is produced to be then added to A
        }
      }

      map_mutex_.unlock();

    } else {
      ROS_WARN("Failed to lock map_mutex_");
    }

  }

  else if (refresh_id_ == "b") {
    if (map_mutex_b_.try_lock()) {
      if (b_add_history_to_b_) {
        auto add_history_start_time = std::chrono::system_clock::now();
        ROS_INFO("Adding history to refreshed map");
        auto history_size = history_->points.size();
        std::cout << history_size << std::endl;
        for (size_t ii = 0; ii < history_->points.size(); ++ii) {
          const Point p = points->points[ii];
          map_octree_b_->addPointToCloud(p, map_data_b_);
        }
        auto add_history_end_time = std::chrono::system_clock::now();
        std::chrono::duration<double> add_history_duration =
            add_history_end_time - add_history_start_time;
        ROS_INFO_STREAM("Added history in " << add_history_duration.count()
                                            << " s");
        history_->clear();
        b_add_history_to_b_ = false;
      }

      double min_x, min_y, min_z, max_x, max_y, max_z;
      bool isInBox;
      map_octree_b_->getBoundingBox(min_x, min_y, min_z, max_x, max_y, max_z);
      // Iterate over points in the input point cloud, inserting them into the
      // map if there is not already a point in the same voxel.
      for (size_t ii = 0; ii < points->points.size(); ++ii) {
        const Point p = points->points[ii];

        isInBox = (p.x >= min_x && p.x <= max_x) &&
            (p.y >= min_y && p.y <= max_y) && (p.z >= min_z && p.z <= max_z);
        if (!isInBox || !map_octree_b_->isVoxelOccupiedAtPoint(p)) {
          map_octree_b_->addPointToCloud(p, map_data_b_);
          incremental_points->push_back(p);
          if (b_keep_history_)
            history_->push_back(
                p); // This history is produced to be then added to B
        }
      }

      map_mutex_b_.unlock();

    } else {
      ROS_WARN("Failed to lock map_mutex_b_");
    }
  }

  auto t_end = std::chrono::high_resolution_clock::now();
  double elapsed_time_ms =
      std::chrono::duration<double, std::milli>(t_end - t_start).count();
  std_msgs::Float64 elapsed_time_ms_ros;
  elapsed_time_ms_ros.data = elapsed_time_ms;
  adding_to_map_pub_.publish(elapsed_time_ms_ros);

  // Publish the incremental map update.
  incremental_points->header = points->header;
  incremental_points->header.frame_id = fixed_frame_id_;
  PublishMapUpdate(*incremental_points);

  map_updated_ = true;

  return true;
}

bool PointCloudMultiThreadedMapper::ApproxNearestNeighbors(
    const PointCloud& points, PointCloud* neighbors) {
  if (!initialized_) {
    ROS_ERROR("%s: Not initialized.", name_.c_str());
  }

  if (neighbors == NULL) {
    ROS_ERROR("%s: Output argument is null.", name_.c_str());
  }

  neighbors->points.clear();
  neighbors->resize(points.points.size());
  auto no_points = std_msgs::UInt64();
  no_points.data = points.size();
  no_nearest_points_pub_.publish(no_points);

  std_msgs::Float64 elapsed_time_ms_ros;
  auto t_start = std::chrono::high_resolution_clock::now();

  // Iterate over points in the input point cloud, finding the nearest neighbor
  // for every point and storing it in the output array.
  int enable_omp = (1 < 4);

  omp_set_num_threads(4);
#pragma omp parallel for schedule(dynamic, 1)
  for (size_t ii = 0; ii < points.points.size(); ++ii) {
    // Search for nearest neighbor and store.
    float unused = 0.f;
    int result_index = -1;

    if (refresh_id_ == "a") {
      map_octree_->approxNearestSearch(points.points[ii], result_index, unused);
      neighbors->points[ii] = map_data_->points[result_index];
    } else if (refresh_id_ == "b") {
      map_octree_b_->approxNearestSearch(
          points.points[ii], result_index, unused);
      neighbors->points[ii] = map_data_->points[result_index];
    }
  }

  auto t_end = std::chrono::high_resolution_clock::now();
  double elapsed_time_ms =
      std::chrono::duration<double, std::milli>(t_end - t_start).count();
  elapsed_time_ms_ros.data = elapsed_time_ms;
  search_in_map_pub_.publish(elapsed_time_ms_ros);
  return neighbors->points.size() > 0;
}

void PointCloudMultiThreadedMapper::PublishMap() {
  if (map_pub_.getNumSubscribers() > 0 || !b_publish_only_with_subscribers_) {
    if (initialized_ && map_updated_) {
      // Use a new thread to publish the map to avoid blocking main thread
      // on concurrent calls.
      if (publish_thread_.joinable()) {
        publish_thread_.join();
      }
      publish_thread_ =
          std::thread(&PointCloudMultiThreadedMapper::PublishMapThread, this);
    }
  }
}

void PointCloudMultiThreadedMapper::PublishMapThread() {
  if (refresh_id_ == "a") {
    map_mutex_.lock();
    map_pub_.publish(map_data_);
    // Don't publish again until we get another map update.
    map_updated_ = false;
    map_mutex_.unlock();
  } else {
    map_mutex_b_.lock();
    map_pub_.publish(map_data_b_);
    map_b_updated_ = false;
    map_mutex_b_.unlock();
  }
}

void PointCloudMultiThreadedMapper::PublishMapFrozen() {
  if (initialized_ && map_frozen_pub_.getNumSubscribers() > 0) {
    // Use a new thread to publish the map to avoid blocking main thread
    // on concurrent calls.
    if (publish_frozen_thread_.joinable()) {
      publish_frozen_thread_.join();
    }
    publish_frozen_thread_ = std::thread(
        &PointCloudMultiThreadedMapper::PublishMapFrozenThread, this);
  }
}

void PointCloudMultiThreadedMapper::PublishMapFrozenThread() {
  map_frozen_mutex_.lock();
  ROS_INFO_STREAM("Publishing frozen map");
  map_frozen_pub_.publish(map_data_);
  // Don't publish again until we get another map update.
  map_frozen_mutex_.unlock();
}

void PointCloudMultiThreadedMapper::PublishMapUpdate(
    const PointCloud& incremental_points) {
  // Publish the incremental points for visualization.
  incremental_map_pub_.publish(incremental_points);
}

void PointCloudMultiThreadedMapper::PublishMapInfo() {
  // When do we want to publish: When points are inserted or the one done in
  // Base station. Why is it so in base station
  if (!b_publish_map_info_) {
    return;
  }

  core_msgs::MapInfo map_info;

  // If the map has been recently updated
  if (initialized_ && map_updated_) {
    // Collect map properties
    map_info.header.stamp =
        ros::Time(map_data_->header.stamp / ((uint64_t)1e6),
                  (map_data_->header.stamp % ((uint64_t)1e6)) * 1e3);
    map_info.header.frame_id = map_data_->header.frame_id;
    map_info.size = map_data_->size();
    map_info.initialized = initialized_;

    // Start stepping through
    int current_depth = -1;
    int depth = -1;
    int target_depth;
    int depth_count = 0;
    std::vector<int> count_per_depth;
    double voxel_side_at_depth;

    // find the depth that we want - depth first search
    for (auto df_itr = map_octree_->depth_begin();
         df_itr != map_octree_->depth_end();
         df_itr++) {
      depth = df_itr.getCurrentOctreeDepth();
      voxel_side_at_depth =
          std::sqrt(map_octree_->getVoxelSquaredSideLen(depth));

      if (voxel_side_at_depth > volume_voxel_size - 0.2 &&
          voxel_side_at_depth < volume_voxel_size + 0.2) {
        // If the side length is around 0.5
        target_depth = depth;
        break;
      }
    }

    for (auto octree_itr = map_octree_->breadth_begin();
         octree_itr != map_octree_->breadth_end();
         octree_itr++) {
      // Check the current depth
      depth = octree_itr.getCurrentOctreeDepth();
      if (depth < target_depth) {
        // Skip this - doesn't contain what we want
        octree_itr++;
        continue;
      } else if (depth > target_depth) {
        break;
      }

      depth_count++;
    }

    // Compute volume
    double volume = depth_count * std::pow(voxel_side_at_depth, 3.0);

    ROS_INFO_STREAM("Point cloud Volume is: "
                    << volume << ", from " << depth_count
                    << " voxels with side length " << voxel_side_at_depth);
    map_info.volume = volume;

    // Publish
    map_info_pub_.publish(map_info);
  }
}

void PointCloudMultiThreadedMapper::SetBoxFilterSize(
    const int box_filter_size) {
  box_filter_size_ = box_filter_size;
  box_filter_.setMin(Eigen::Vector4f(
      -box_filter_size_, -box_filter_size_, -box_filter_size_, 1.0));
  box_filter_.setMax(Eigen::Vector4f(
      box_filter_size_, box_filter_size_, box_filter_size_, 1.0));
}

void PointCloudMultiThreadedMapper::Refresh(
    const geometry_utils::Transform3& current_pose) {
  Eigen::Vector3f current_translation(3), current_rotation(3);
  current_translation << current_pose.translation.data[0],
      current_pose.translation.data[1], current_pose.translation.data[2];
  current_rotation << current_pose.rotation.Roll(),
      current_pose.rotation.Pitch(), current_pose.rotation.Yaw();
  box_filter_.setTranslation(current_translation);
  box_filter_.setRotation(current_rotation);

  if (refresh_id_ == "a") {
    box_filter_.setInputCloud(map_data_);
  } else if (refresh_id_ == "b") {
    box_filter_.setInputCloud(map_data_b_);
  }

  if (refresh_thread_.joinable()) {
    refresh_thread_.join();
  }
  refresh_thread_ =
      std::thread(&PointCloudMultiThreadedMapper::RefreshThread, this);
}

void PointCloudMultiThreadedMapper::RefreshThread() {
  auto t_start = std::chrono::high_resolution_clock::now();

  if (refresh_id_ == "a") {
    // INPUT: a, OUTPUT: b
    b_keep_history_ = true;
    auto refresh_start_time = std::chrono::system_clock::now();
    box_filter_.filter(*map_data_b_);
    map_data_b_->header.frame_id = fixed_frame_id_;
    map_octree_b_.reset(new Octree(octree_resolution_));
    map_octree_b_->setInputCloud(map_data_b_);
    map_octree_b_->addPointsFromInputCloud();
    auto refresh_end_time = std::chrono::system_clock::now();
    std::chrono::duration<double> refresh_duration =
        refresh_end_time - refresh_start_time;
    ROS_INFO_STREAM("refresh_duration: " << refresh_duration.count());
    b_keep_history_ = false;
    refresh_id_ = "b";
    b_add_history_to_b_ = true;
  } else if (refresh_id_ == "b") {
    // INPUT: b, OUTPUT: a
    b_keep_history_ = true;
    auto refresh_start_time = std::chrono::system_clock::now();
    box_filter_.filter(*map_data_);
    map_data_->header.frame_id = fixed_frame_id_;
    map_octree_.reset(new Octree(octree_resolution_));
    map_octree_->setInputCloud(map_data_);
    map_octree_->addPointsFromInputCloud();

    auto refresh_end_time = std::chrono::system_clock::now();
    std::chrono::duration<double> refresh_duration =
        refresh_end_time - refresh_start_time;
    ROS_INFO_STREAM("refresh_duration: " << refresh_duration.count());
    b_keep_history_ = false;
    refresh_id_ = "a";
    b_add_history_to_a_ = true;
  }
  auto t_end = std::chrono::high_resolution_clock::now();

  double elapsed_time_ms =
      std::chrono::duration<double, std::milli>(t_end - t_start).count();
  std_msgs::Float64 elapsed_time_ms_ros;
  elapsed_time_ms_ros.data = elapsed_time_ms;
  delete_from_map_pub_.publish(elapsed_time_ms_ros);
}
